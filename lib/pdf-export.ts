import jsPDF from 'jspdf';
import { Participant, Expense, Settlement, Currency } from './types';
import { formatAmount } from './currency';

export interface ExportData {
  participants: Participant[];
  expenses: Expense[];
  settlements: Settlement[];
  currency: Currency;
  exportDate: Date;
}

export function generateMarkdownReport(data: ExportData): string {
  const { participants, expenses, settlements, currency, exportDate } = data;
  
  const getParticipantName = (id: string) => {
    return participants.find(p => p.id === id)?.name || 'Unknown';
  };

  let markdown = `# SplitWise Expense Report\n\n`;
  markdown += `**Generated on:** ${exportDate.toLocaleDateString()} at ${exportDate.toLocaleTimeString()}\n`;
  markdown += `**Currency:** ${currency.name} (${currency.symbol})\n\n`;

  // Participants Summary
  markdown += `## Participants Summary\n\n`;
  markdown += `| Name | Total Contributed | Total Owed | Balance |\n`;
  markdown += `|------|------------------|------------|----------|\n`;
  
  participants.forEach(participant => {
    const balance = participant.totalContributed - participant.totalOwed;
    const balanceFormatted = balance >= 0 
      ? `+${formatAmount(balance, currency)}` 
      : `-${formatAmount(Math.abs(balance), currency)}`;
    
    markdown += `| ${participant.name} | ${formatAmount(participant.totalContributed, currency)} | ${formatAmount(participant.totalOwed, currency)} | ${balanceFormatted} |\n`;
  });

  // Expenses Details
  markdown += `\n## Expense Details\n\n`;
  if (expenses.length === 0) {
    markdown += `*No expenses recorded.*\n\n`;
  } else {
    markdown += `| Date | Description | Amount | Paid By | Split Between | Split Type |\n`;
    markdown += `|------|-------------|--------|---------|---------------|------------|\n`;
    
    expenses.forEach(expense => {
      const splitBetween = expense.participants.map(id => getParticipantName(id)).join(', ');
      const splitType = expense.customSplits ? 'Custom' : 'Equal';
      const date = new Date(expense.date).toLocaleDateString();
      
      markdown += `| ${date} | ${expense.description} | ${formatAmount(expense.amount, currency)} | ${getParticipantName(expense.paidBy)} | ${splitBetween} | ${splitType} |\n`;
    });

    // Custom splits details
    const customSplitExpenses = expenses.filter(e => e.customSplits);
    if (customSplitExpenses.length > 0) {
      markdown += `\n### Custom Split Details\n\n`;
      customSplitExpenses.forEach(expense => {
        markdown += `**${expense.description}:**\n`;
        markdown += `| Participant | Percentage | Amount |\n`;
        markdown += `|-------------|------------|--------|\n`;
        
        Object.entries(expense.customSplits!).forEach(([participantId, percentage]) => {
          const amount = (expense.amount * percentage) / 100;
          markdown += `| ${getParticipantName(participantId)} | ${percentage}% | ${formatAmount(amount, currency)} |\n`;
        });
        markdown += `\n`;
      });
    }
  }

  // Settlement Summary
  markdown += `## Settlement Summary\n\n`;
  if (settlements.length === 0) {
    markdown += `*All participants are settled up! No payments required.*\n\n`;
  } else {
    markdown += `| From | To | Amount | Status |\n`;
    markdown += `|------|----|---------|---------|\n`;
    
    settlements.forEach(settlement => {
      markdown += `| ${getParticipantName(settlement.from)} | ${getParticipantName(settlement.to)} | ${formatAmount(settlement.amount, currency)} | Pending |\n`;
    });

    const totalSettlements = settlements.reduce((sum, s) => sum + s.amount, 0);
    markdown += `\n**Total Settlement Amount:** ${formatAmount(totalSettlements, currency)}\n`;
    markdown += `**Number of Transactions:** ${settlements.length}\n\n`;
  }

  // Summary Statistics
  const totalExpenses = expenses.reduce((sum, e) => sum + e.amount, 0);
  const avgExpensePerPerson = participants.length > 0 ? totalExpenses / participants.length : 0;
  
  markdown += `## Summary Statistics\n\n`;
  markdown += `| Metric | Value |\n`;
  markdown += `|--------|-------|\n`;
  markdown += `| Total Participants | ${participants.length} |\n`;
  markdown += `| Total Expenses | ${expenses.length} |\n`;
  markdown += `| Total Amount Spent | ${formatAmount(totalExpenses, currency)} |\n`;
  markdown += `| Average per Person | ${formatAmount(avgExpensePerPerson, currency)} |\n`;
  markdown += `| Settlements Required | ${settlements.length} |\n\n`;

  markdown += `---\n\n`;
  markdown += `*Report generated by SplitWise - Expense Splitter*\n`;

  return markdown;
}

export async function exportToPDF(data: ExportData): Promise<void> {
  const markdown = generateMarkdownReport(data);
  
  // Create a temporary div to render the markdown as HTML
  const tempDiv = document.createElement('div');
  tempDiv.style.position = 'absolute';
  tempDiv.style.left = '-9999px';
  tempDiv.style.top = '-9999px';
  tempDiv.style.width = '800px';
  tempDiv.style.padding = '40px';
  tempDiv.style.fontFamily = 'Arial, sans-serif';
  tempDiv.style.fontSize = '12px';
  tempDiv.style.lineHeight = '1.6';
  tempDiv.style.color = '#000';
  tempDiv.style.backgroundColor = '#fff';
  
  // Convert markdown to HTML (simple conversion)
  const htmlContent = markdownToHTML(markdown);
  tempDiv.innerHTML = htmlContent;
  
  document.body.appendChild(tempDiv);
  
  try {
    // Create PDF
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    
    // Add title
    pdf.setFontSize(20);
    pdf.setFont('helvetica', 'bold');
    pdf.text('SplitWise Expense Report', margin, margin + 10);
    
    // Add generation info
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`Generated on: ${data.exportDate.toLocaleDateString()} at ${data.exportDate.toLocaleTimeString()}`, margin, margin + 20);
    pdf.text(`Currency: ${data.currency.name} (${data.currency.symbol})`, margin, margin + 25);
    
    let yPosition = margin + 40;
    
    // Add participants table
    if (data.participants.length > 0) {
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Participants Summary', margin, yPosition);
      yPosition += 10;
      
      // Table headers
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Name', margin, yPosition);
      pdf.text('Contributed', margin + 40, yPosition);
      pdf.text('Owed', margin + 80, yPosition);
      pdf.text('Balance', margin + 120, yPosition);
      yPosition += 5;
      
      // Table data
      pdf.setFont('helvetica', 'normal');
      data.participants.forEach(participant => {
        const balance = participant.totalContributed - participant.totalOwed;
        const balanceText = balance >= 0 
          ? `+${formatAmount(balance, data.currency)}` 
          : `-${formatAmount(Math.abs(balance), data.currency)}`;
        
        pdf.text(participant.name, margin, yPosition);
        pdf.text(formatAmount(participant.totalContributed, data.currency), margin + 40, yPosition);
        pdf.text(formatAmount(participant.totalOwed, data.currency), margin + 80, yPosition);
        pdf.text(balanceText, margin + 120, yPosition);
        yPosition += 5;
        
        if (yPosition > pageHeight - 30) {
          pdf.addPage();
          yPosition = margin;
        }
      });
      
      yPosition += 10;
    }
    
    // Add expenses table
    if (data.expenses.length > 0) {
      if (yPosition > pageHeight - 60) {
        pdf.addPage();
        yPosition = margin;
      }
      
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Expense Details', margin, yPosition);
      yPosition += 10;
      
      // Table headers
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Date', margin, yPosition);
      pdf.text('Description', margin + 25, yPosition);
      pdf.text('Amount', margin + 80, yPosition);
      pdf.text('Paid By', margin + 120, yPosition);
      yPosition += 5;
      
      // Table data
      pdf.setFont('helvetica', 'normal');
      data.expenses.forEach(expense => {
        const date = new Date(expense.date).toLocaleDateString();
        const paidBy = data.participants.find(p => p.id === expense.paidBy)?.name || 'Unknown';
        
        pdf.text(date, margin, yPosition);
        pdf.text(expense.description.substring(0, 20), margin + 25, yPosition);
        pdf.text(formatAmount(expense.amount, data.currency), margin + 80, yPosition);
        pdf.text(paidBy, margin + 120, yPosition);
        yPosition += 5;
        
        if (yPosition > pageHeight - 30) {
          pdf.addPage();
          yPosition = margin;
        }
      });
      
      yPosition += 10;
    }
    
    // Add settlements
    if (data.settlements.length > 0) {
      if (yPosition > pageHeight - 60) {
        pdf.addPage();
        yPosition = margin;
      }
      
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Settlement Summary', margin, yPosition);
      yPosition += 10;
      
      // Table headers
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'bold');
      pdf.text('From', margin, yPosition);
      pdf.text('To', margin + 50, yPosition);
      pdf.text('Amount', margin + 100, yPosition);
      yPosition += 5;
      
      // Table data
      pdf.setFont('helvetica', 'normal');
      data.settlements.forEach(settlement => {
        const fromName = data.participants.find(p => p.id === settlement.from)?.name || 'Unknown';
        const toName = data.participants.find(p => p.id === settlement.to)?.name || 'Unknown';
        
        pdf.text(fromName, margin, yPosition);
        pdf.text(toName, margin + 50, yPosition);
        pdf.text(formatAmount(settlement.amount, data.currency), margin + 100, yPosition);
        yPosition += 5;
        
        if (yPosition > pageHeight - 30) {
          pdf.addPage();
          yPosition = margin;
        }
      });
    }
    
    // Save the PDF
    const fileName = `splitwise-report-${new Date().toISOString().split('T')[0]}.pdf`;
    pdf.save(fileName);
    
  } finally {
    // Clean up
    document.body.removeChild(tempDiv);
  }
}

function markdownToHTML(markdown: string): string {
  return markdown
    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/^\| (.*) \|$/gm, '<tr><td>$1</td></tr>')
    .replace(/^\|---.*\|$/gm, '')
    .replace(/<tr><td>(.*?)<\/td><\/tr>/g, (match, content) => {
      const cells = content.split(' | ').map((cell: string) => `<td>${cell}</td>`).join('');
      return `<tr>${cells}</tr>`;
    })
    .replace(/(<tr>.*<\/tr>)/s, '<table border="1" cellpadding="5" cellspacing="0">$1</table>')
    .replace(/\n/g, '<br>');
}